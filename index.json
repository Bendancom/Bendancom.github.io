[{"categories":["C++"],"content":"C++中实现了单映射STL容器std::map，但实际业务中需要的是多映射类型的对任意数据的快速查找。虽可以使用多个std::map，但这对空间浪费过大，因而作者自行实现一个简易的多索引泛型容器库。 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"实现思路 使用关联容器或自定义关联容器存储索引 使用容器存储数据表，容器类型可根据IO特性自行调整 键：数据的引用，以减少重复数据。 值：数据在总表中的位置(指针)。 容器是不能存储引用的，使用std::reference_wrapper来包装引用并存储 使用 std::tuple 封装数据。 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"标准库使用 \u003ctype_traits\u003e \u003cranges\u003e \u003ctuple\u003e \u003cvector\u003e \u003cconcepts\u003e ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"泛型 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"索引类的键值对类型 键 std::reference_wrapper 的本质是指针，即在内存中占用sizeof(size_t)大小字节，由此可进行分类： $\\geqslant$sizeof(size_t)的使用 std::reference_wrapper $\u003c$sizeof(size_t)的使用其本身 那么类型别名模板如下： template \u003ctypename T\u003e using map_key = std::conditional_t\u003csizeof(T) \u003c sizeof(size_t), T, std::reference_wrapper\u003cT\u003e\u003e; 值 泛型容器，其索引值为该泛型容器的迭代器 随机访问容器，其索引值可优化为内存地址 为泛型选择了第一种。 template \u003ctemplate \u003ctypename T, typename... Args\u003e typename container, typename... Args\u003e using map_value = std::ranges::iterator_t\u003ccontainer\u003cstd::tuple\u003cArgs...\u003e\u003e\u003e; ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:1","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"索引容器包装/解封 map_wrapper 对单个索引容器的包装 map_wrapper封装 template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename T\u003e struct map_wrapper {}; map_wrapper_expand 运用模板特化读取封装的单个索引容器类型，后接两个类型： K: 键类型 V: 值类型 直接组成一个完好的索引类。 template \u003ctypename T, typename K, typename V\u003e struct map_wrapper_expand; template \u003c template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename args\u003e typename T, template \u003ctypename, typename, typename... Args\u003e typename Other, typename K, typename V\u003e struct map_wrapper_expand\u003cT\u003cOther\u003e, K, V\u003e { using type = Other\u003cK, V\u003e; }; maps_wrapper 对不同索引的整体封装 maps_wrapper 封装 export template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename... Others\u003e struct maps_wrapper {}; maps_wrapper_expand 通过对 maps_wrapper的展开，对其中的每个索引容器单独使用 map_wrapper 封装，后组合成 std::tuple 的二层封装结构 template\u003ctypename T\u003e struct maps_wrapper_expand; template\u003ctemplate\u003ctemplate\u003ctypename, typename, typename... Args\u003etypename... args\u003etypename T, template\u003ctypename, typename, typename... Args\u003etypename...Others\u003e struct maps_wrapper_expand\u003cT\u003cOthers...\u003e\u003e { using type = std::tuple\u003cmap_wrapper\u003cOthers\u003e...\u003e; }; 踩坑 template\u003ctypename T\u003e struct maps_wrapper_expand; template\u003ctemplate\u003ctemplate\u003ctypename, typename, typename... Args\u003etypename... args\u003etypename T, template\u003ctypename, typename, typename... Args\u003etypename...Others\u003e struct maps_wrapper_expand\u003cT\u003cOthers...\u003e\u003e { template\u003ctypename V,typename... K\u003e using type = std::tuple\u003cOthers\u003cK,V\u003e...\u003e; }; 这个方法看起来可以直接一步到位，只要如下使用即可： maps_wrapper_expand\u003c maps_wrapper\u003c std::map, std::map\u003e\u003e ::type\u003c long double, int, int \u003e maps; 以上确实能通过编译。 但在引入模板后，不能通过编译。 模板如下： template\u003ctypename Maps,typename V,typename... K\u003e using maps_tuple_t =maps_wrapper_expand\u003cMaps\u003e::type\u003cV,K...\u003e; 探查下来问题大概出在可变参数模板类内的类型别名模板定义，不能在可变参数模板类中嵌套类型别名模板。 maps_tuple_before 原理是将两种可变参数分别按顺序封装到 std::tuple 中，再利用 size_t... N 统一进行展开并拼装为完整的索引类，最后封装至std::tuple中。 使用map_wrapper_expand来进行拼装 template \u003ctypename T, typename K, typename V, typename Index\u003e struct maps_tuple_before; template \u003ctypename T, typename K, typename V, size_t... N\u003e struct maps_tuple_before\u003cT, K, V, std::index_sequence\u003cN...\u003e\u003e { using type = std::tuple\u003ctypename map_wrapper_expand\u003c std::tuple_element_t\u003cN, typename maps_wrapper_expand\u003cT\u003e::type\u003e, std::tuple_element_t\u003cN, K\u003e, V\u003e::type...\u003e; }; maps_tuple 这就是最终的对索引容器处理的类，是对maps_tuple_before进行一个模板简化。 在其上增添了自动生成 std::index_sequence\u003cN...\u003e template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e struct maps_tuple { using type = maps_tuple_before\u003c associative_containers, std::tuple\u003cmap_key\u003cargs\u003e...\u003e, map_value\u003ccontainer, args...\u003e, std::make_index_sequence\u003csizeof...(args)\u003e\u003e::type; }; ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:2","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"multi_index 使用约束与模板进行泛型匹配 应有如下类型 数据容器 索引容器包装，其中含有各数据所需索引容器类型 数据 模板 template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e requires requires (......) { ...... } class multi_index{ ...... }; 约束 由于泛型的需求，其requires要求应为最普适，即： 数据表容器应为 common_range\u0026sized_range类型 数据量应与索引容器量一致 索引表容器应为 common_range类型，并可被std::get函数解包，且有如下函数： find insert erase count 而索引总类是由 std::tuple进行包装的，因而须函数展开进行约束计算。 requires requires( maps_tuple_t\u003ccontainer, associative_containers, args...\u003e maps, map_key\u003cargs\u003e... keys, map_value\u003ccontainer, args...\u003e value) { std::ranges::common_range\u003ccontainer\u003cstd::tuple\u003cargs...\u003e\u003e\u003e; std::ranges::sized_range\u003ccontainer\u003cstd::tuple\u003cargs...\u003e\u003e\u003e; sizeof...(args) == std::tuple_size_v\u003cdecltype(maps)\u003e; // common_range [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::ranges::common_range\u003cstd::tuple_element_t\u003cN, decltype(maps)\u003e\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); // find [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).find(keys))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // count [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003cdecltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).count(keys))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // erase [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).erase(std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); // insert [\u0026maps, \u0026value]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).insert({keys, value}))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // can decompress by function std::get\u003c0\u003e [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(keys), decltype(std::get\u003c0\u003e(*std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // can decompress by function std::get\u003c1\u003e [\u0026maps, \u0026value]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(value), decltype(std::get\u003c1\u003e(*std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:3","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"函数实现 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"辅助函数 模板约束中并未对索引容器要求clear与swap函数，因而需requires检验 template \u003csize_t... N\u003e constexpr void make_indexs(iterator data, std::index_sequence\u003cN...\u003e) { (std::get\u003cN\u003e(map).insert({std::get\u003cN\u003e(*data), data}), ...); } template \u003csize_t... N\u003e constexpr void erase_indexs(const iterator \u0026iter, std::index_sequence\u003cN...\u003e) { (std::get\u003cN\u003e(map).erase(std::get\u003cN\u003e(map).find(std::get\u003cN\u003e(*iter))), ...); } template \u003csize_t... N\u003e constexpr void clear_indexs(std::index_sequence\u003cN...\u003e) requires requires(multi_index_t th) { (std::get\u003cN\u003e(th).clear(), ...); } { (std::get\u003cN\u003e(map).clear, ...); } template \u003csize_t... N\u003e constexpr void swap_indexs(multi_index_t \u0026other, std::index_sequence\u003cN...\u003e) requires requires(multi_index_t th, multi_index_t other) { (std::get\u003cN\u003e(th).swap(std::get\u003cN\u003e(other)), ...); } { (std::get\u003cN\u003e(map).swap(std::get\u003cN\u003e(other)), ...); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:1","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"初始化 default constexpr multi_index() {} Range template \u003cstd::ranges::input_range Rng\u003e requires requires { std::convertible_to\u003cstd::ranges::range_reference_t\u003cRng\u003e, data_list_t\u003e; } constexpr multi_index(Rng \u0026\u0026t) : data_sheet(std::ranges::to\u003cdata_sheet_t\u003e(t)) { for (iterator iter = data_sheet.begin(); iter != data_sheet.end(); iter++) make_indexs(iter, std::make_index_sequence\u003csizeof...(Args)\u003e{}); } copy/move constexpr multi_index(const multi_index\u003ccontainer, associative_container, Args...\u003e \u0026d) : data_sheet(d.data_sheet), map(d.map) {} ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:2","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"迭代 begin/cbegin constexpr iterator begin() { return std::ranges::begin(data_sheet); } constexpr const_iterator cbegin() const { return std::ranges::cbegin(data_sheet); } end/cend constexpr iterator end() { return std::ranges::end(data_sheet); } constexpr const_iterator cend() const { return std::ranges::cend(data_sheet); } rbegin/crbegin constexpr reverse_iterator rbegin() requires requires(data_sheet_t data) { data.rbegin(); } { return data_sheet.rbegin(); } constexpr const const_reverse_iterator crbegin() const requires requires(data_sheet_t data) { data.crbegin(); } { return data_sheet.crbegin(); } rend/crend constexpr reverse_iterator rend() requires requires(data_sheet_t data) { data.rend(); } { return data_sheet.rend(); } constexpr const const_reverse_iterator crend() const requires requires(data_sheet_t data) { data.crend(); } { return data_sheet.crend(); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:3","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"查询 size constexpr size_t size() const { return data_sheet.size(); } empty constexpr bool empty() const requires requires(data_sheet_t data) { data.empty(); } { return data_sheet.empty(); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:4","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"修改 insert/insert_range constexpr iterator insert(const iterator \u0026iter, const data_list_t \u0026data) { iterator tmp = data_sheet.insert(iter, data); make_indexs(tmp, std::make_index_sequence\u003csizeof...(Args)\u003e{}); return tmp; } template\u003cstd::input_range Rng\u003e requires requires { std::convertible_to\u003cstd::ranges::range_reference_t\u003cRng\u003e, data_list_t\u003e; } constexpr iterator insert_range(const iterator \u0026iter, Rng \u0026\u0026data) { const size_t size = data.size(); iterator tmp = data_sheet.insert_range(iter, data); iterator i = tmp; for (size_t j = 0; j \u003c size; j++) { make_indexs(i, std::make_index_sequence\u003csizeof...(Args)\u003e{}); i++; } return tmp; } push_back/append_range constexpr void push_back(const data_list_t \u0026data) { data_sheet.push_back(data); make_indexs(std::prev(std::ranges::end(data_sheet)), std::make_index_sequence\u003csizeof...(Args)\u003e{}); return; } template\u003cstd::input_range Rng\u003e requires requires { std::convertible_to\u003cstd::ranges::range_reference_t\u003cRng\u003e, data_list_t\u003e; } constexpr void append_range(Rng \u0026\u0026data) { iterator tmp = std::prev(data.end()); data_sheet.append_range(data); for (tmp++; tmp != data.end(); tmp++) make_indexs(tmp, std::make_index_sequence\u003csizeof...(Args)\u003e{}); } constexpr void clear() requires requires(data_sheet_t data, maps_tuple_t maps) { data.clear(); maps.clear(); } { data_sheet.clear(); clear_indexs(std::make_index_sequence\u003csizeof...(args)\u003e{}); } erase/pop_back/clear/pop_front constexpr iterator erase(const iterator \u0026iter) requires requires(data_sheet_t data, iterator iter) { data.erase(iter); } { erase_indexs(iter, std::make_index_sequence\u003csizeof...(args)\u003e{}); return data_sheet.erase(iter); } constexpr void pop_back() requires requires(data_sheet_t data) { data.pop_back(); } { erase_indexs(data_sheet.end()--, std::make_index_sequence\u003csizeof...(args)\u003e{}); data_sheet.pop_back(); } constexpr void clear() requires requires(data_sheet_t data, maps_tuple_t maps) { data.clear(); maps.clear(); } { data_sheet.clear(); clear_indexs(std::make_index_sequence\u003csizeof...(args)\u003e{}); } constexpr void pop_front() requires requires(data_sheet_t data) { data.pop_front(); } { erase_indexs(data_sheet.begin(), std::make_index_sequence\u003csizeof...(args)\u003e{}); data_sheet.pop_front(); } swap/resize constexpr void resize(const size_t \u0026size) requires requires(data_sheet_t data, size_t size) { data.resize(size); } { data_sheet.resize(size); } constexpr void swap(multi_index\u003ccontainer, associative_containers, args...\u003e \u0026other) requires requires(data_sheet_t data, data_sheet_t \u0026other) { data.swap(other); } { data_sheet.swap(other.data_sheet); swap_indexs(other.map, std::make_index_sequence\u003csizeof...(args)\u003e{}); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:5","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"查找 find template \u003csize_t N\u003e constexpr std::vector\u003citerator\u003e find(const std::tuple_element_t\u003cN, data_list_t\u003e \u0026data) { std::vector\u003citerator\u003e tmp; auto iter = std::get\u003cN\u003e(map).find(data); if (iter != std::get\u003cN\u003e(map).end()) for (size_t i = 0; i \u003c std::get\u003cN\u003e(map).count(std::get\u003c0\u003e(*iter)); i++) tmp.push_back(std::get\u003c1\u003e(*++iter)); return tmp; } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:6","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"总代码 如下便是全部代码，使用modules进行接口管理，避免过程类/结构的暴露。 export module multi_index; import \u003cvector\u003e; import \u003ctype_traits\u003e; import \u003cranges\u003e; import \u003cconcepts\u003e; import \u003ctuple\u003e; template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename T\u003e struct map_wrapper {}; template \u003ctypename T, typename K, typename V\u003e struct map_wrapper_expand; template \u003c template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename args\u003e typename T, template \u003ctypename, typename, typename... Args\u003e typename Other, typename K, typename V\u003e struct map_wrapper_expand\u003cT\u003cOther\u003e, K, V\u003e { using type = Other\u003cK, V\u003e; }; export template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename... Others\u003e struct maps_wrapper {}; template \u003ctypename T\u003e struct maps_wrapper_expand; template \u003ctemplate \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename... args\u003e typename T, template \u003ctypename, typename, typename... Args\u003e typename... Others\u003e struct maps_wrapper_expand\u003cT\u003cOthers...\u003e\u003e { using type = std::tuple\u003cmap_wrapper\u003cOthers\u003e...\u003e; }; template \u003ctypename T\u003e using map_key = std::conditional_t\u003csizeof(T) \u003c sizeof(size_t), T, std::reference_wrapper\u003cT\u003e\u003e; template \u003ctemplate \u003ctypename T, typename... Args\u003e typename container, typename... Args\u003e using map_value = std::ranges::iterator_t\u003ccontainer\u003cstd::tuple\u003cArgs...\u003e\u003e\u003e; template \u003ctypename T, typename K, typename V, typename Index\u003e struct maps_tuple_before; template \u003ctypename T, typename K, typename V, size_t... N\u003e struct maps_tuple_before\u003cT, K, V, std::index_sequence\u003cN...\u003e\u003e { using type = std::tuple\u003ctypename map_wrapper_expand\u003c std::tuple_element_t\u003cN, typename maps_wrapper_expand\u003cT\u003e::type\u003e, std::tuple_element_t\u003cN, K\u003e, V\u003e::type...\u003e; }; template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e struct maps_tuple { using type = maps_tuple_before\u003c associative_containers, std::tuple\u003cmap_key\u003cargs\u003e...\u003e, map_value\u003ccontainer, args...\u003e, std::make_index_sequence\u003csizeof...(args)\u003e\u003e::type; }; template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e using maps_tuple_t = maps_tuple\u003ccontainer, associative_containers, args...\u003e::type; export template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e requires requires( maps_tuple_t\u003ccontainer, associative_containers, args...\u003e maps, map_key\u003cargs\u003e... keys, map_value\u003ccontainer, args...\u003e value) { std::ranges::common_range\u003ccontainer\u003cstd::tuple\u003cargs...\u003e\u003e\u003e; std::ranges::sized_range\u003ccontainer\u003cstd::tuple\u003cargs...\u003e\u003e\u003e; sizeof...(args) == std::tuple_size_v\u003cdecltype(maps)\u003e; // common_range [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::ranges::common_range\u003cstd::tuple_element_t\u003cN, decltype(maps)\u003e\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); // find [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).find(keys))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // count [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003cdecltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).count(keys))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // erase [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).erase(std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); // insert [\u0026maps, \u0026value]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).insert({keys, value}))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // can decompress by function std::get\u003c0\u003e [\u0026maps]\u003csize_t... N\u003e(std::index_sequenc","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:5:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Markdown"],"content":"本篇技术手册由个人汇总而成。旨在撰写Markdown时便于记忆查询 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:0:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"标题 在 MarkDown 中，将#置于开头并在其后加上一个或一个以上空格用于标记标题，#越多，代表标题级数越多，最多六级。 #一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:1:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"语法 对于段落的判定，换行即可 部分MarkDown编辑器若要文字段落换行，需在换行后前一段后面加上两个或两个以上空格(如VsCode)。 用于标记的空格只能用半角空格。 如果想要写的美观，可以参考MarkDown规则文档 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:2:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"段落样式 Text : 文本 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"首行缩进 不同特殊占位符所占空白是不一样大的。 默认为不缩进。 \u0026emsp; 或\u0026#8195; 全角 \u0026ensp; 或\u0026#8194; 半角 \u0026nbsp; 或\u0026#160; 半角之半角 全角缩进 半角缩进 半角之半角缩进 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"斜体 在需斜体的文字两旁加上一个星号。 *Text* ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"粗体 在需要粗体的文字两旁加上两个星号。 **Text** ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:3","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"粗斜体 在需要粗斜体的文字两旁加上三个星号。 ***Text*** ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:4","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"分隔线 在一行中用三个或三个以上的星号(*)、减号(-)、底线(_)，可以在星号、减号、底线之间插入空格，数量不限。 *** * * * --- - - - ___ _ _ _ ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:5","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"删除线 在需要添加删除线的文字两旁加上两个波浪线。 ~~Text~~ ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:6","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"下划线 可以通过内联HTML的\u003cu\u003eText\u003c/u\u003e标签来实现。 据说有些Markdown编辑器支持++Text++这种。 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:7","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"==背景高亮== ==Text== ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:8","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"脚注 脚注是对文本的补充说明，可以通过 [^Name] 标记，标记后可以在MarkDown文档任意地方进行注释。 注释方法：[^Name]:Text Name : 标记名称 Text : 注释文本 耄耋[^1] 焱[^2] [^1]:年纪八十到九十的老人 [^2]:火花 耄耋1 焱2 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:9","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"列表 MarkDown支持无序列表和有序列表。 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"无序列表 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个或以上空格，然后再填写内容。 同级别星号、加号、减号的混用会导致段落之间的间距的扩大。 Markdown规范推荐全文只用一种符号去表示无序列表。 * 1 * 2 * 3 + 1 + 2 + 3 - 1 - 2 - 3 * 1 + 2 - 3 1 2 3 1 2 3 1 2 3 1 2 3 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"有序列表 有序列表使用阿拉伯数字加上点(.)和一个空格表示。 1. 1 2. 2 3. 3 1 2 3 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"子列表 对无序或有序列表增添缩进即可获得子列表 同样的Markdown规范推荐全文只用一种符号去表示无序列表。 无序子列表在整个层级出现三次及以上后，之后的无序子列表前的符号就相同了。 有序子列表在整个层级出现三次及以上后，之后的有序子列表前的符号就相同了。 * 1 * 2 * 3 * 4 * 5 1. 1 * 1-1 * 1-1-1 * 1-2 1. 1.2.1 * 1-2-1-1 2. 2 1. 2.1 2. 2.2 3. 2.3 1. 2.3.1 2. 2.3.2 3. 2.3.3 1. 2.3.3.1 * 2-3-3-2 * 2-3-3-2-1 1 2 3 4 5 1 1-1 1-1-1 1-2 1.2.1 1-2-1-1 2 2.1 2.2 2.3 2.3.1 2.3.2 2.3.3 2.3.3.1 2-3-3-2 2-3-3-2-1 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:3","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"区块 在段落开头加上\u003e符号后紧跟一个空格。 区块可嵌套，有几层嵌套前面就有几个\u003e符号，\u003e之间用一个或一个以上空格隔开，别忘用空格分开文字与区块标记。 区块可用于列表中，列表中也可以使用区块。使用方法只需标签的叠加。 \u003e 1 \u003e\u003e 2 \u003e\u003e\u003e 3 \u003e 1. 1 \u003e 2. 2 \u003e * 2-1 \u003e * 1 \u003e\u003e + 2 \u003e\u003e\u003e - 3 1 2 3 2-1 1 2 3 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:5:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"代码 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:6:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"片段代码 可以在代码两旁添加反引号(`)向MarkDown表示这是代码。 `printf(\"Hellow World\");` ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:6:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"代码区块 可以用四个空格或一个制表符(Tab)加在区块每一行开头向MarkDown表示这是一段代码区块。 public int Get() { return 1; } 也可以用三个反引号(`)或三个波浪号(~)包裹代码区块，并可以指定一种语言。 ```C++ int* p = 1; ``` ```C# private score = 0; ``` ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:6:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"链接 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:7:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"简单链接 使用[Name](url)或\u003curl\u003e3 Name : 链接名字 url : 地址 [百度](www.baidu.com) \u003cwww.bing.com\u003e 百度 \u003cwww.baidu.com\u003e ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:7:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"高级链接 使用[Name][var]设置一个变量，然后使用[var]:Text在文档其余任意地方给变量赋上链接值。 Name : 标记名称 var : 变量名称 Text : 注释文本 [Google][1] [1]:http://www.google.com ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:7:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"图片 使用![FailText](url \"title\" )来表示图片。 也可以使用![FailText][var]标记，然后使用[var]:url在文档任意地方给变量赋上图片链接值。 FailText : 图片加载显示失败时显示的文本 url : 图片地址 var : 变量名称 title : 图片名称 ![Picture1](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2496571732,442429806\u0026fm=26\u0026gp=0.jpg \"title 1\") ![Picture2][1] [1]:https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2595316365,4277938543\u0026fm=26\u0026gp=0.jpg \"title 2\" ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:8:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"表格 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:9:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"基础 表格的制作使用|符号分隔列，使用一个或一个以上的减号(-)分隔表头和其他行，使用换行分隔行。 注意要在每行开头和结尾加上|表示表格。 |和列之间要有一个或一个以上的空格分隔。 | Price | number | | - | - | | 1 | 2 | | 2 | 1 | ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:9:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"对齐方式 可以用下列三种格式替换减号(-)来分隔表头和其他行并表示对齐方式。 其中减号(-)同理可以一个或一个以上的数量 :- 设置内容和标题栏居左对齐。 -: 设置内容和标题栏居右对齐。 :-: 设置内容和标题栏居中对齐。 | Left | Right | center | | :-----| ----: | :----: | | block | block | block | | block | block | block | ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:9:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"高级技巧 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"HTML元素 可以使用HTML标签。 \u003ckbd\u003eCtrl\u003c/kbd\u003e+\u003ckbd\u003eAlt\u003c/kbd\u003e+\u003ckbd\u003eDel\u003c/kbd\u003e ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"转义 在特定字符前加上一个反斜杠使其单作为文字显示。 MarkDown支持以下特殊字符前加反斜杠。 \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"公式 如果要在编辑器中插入公式，可以使用一个美元符号($)包裹TeX或LaTeX格式的数学公式来实现。 单独显示的LaTeX公式用$$...$$定义。 随着LaTex的更新$与$$不再推荐使用了，行内公式使用\\(与\\)包裹，行间公式使用\\[与\\]包裹。 MathJax公式使用这里不再赘述，详情请自行搜索。 $\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$ \\(x + 1 = y\\) $$\\sum_{i=0}N\\int_{a}{b}g(t,i)\\text{d}t$$ \\[x^2 + y^2 = 1\\] $\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$ (x + 1 = y) $$\\sum_{i=0}N\\int_{a}{b}g(t,i)\\text{d}t$$ [x^2 + y^2 = 1] ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:3","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"流程图 本篇会简单讲解流程图的画法，若要了解其他图表的画法，可以参考 CSDN-【Tools】MarkDown教程(四)-MarkDown中的UML图 流程图需先表示为代码块。 语言目前有三种：flow、mermaid和UML ```flow Code Block ``` ```mermaid Code Block ``` ```sequence Code Block ``` Code Block : 代码块 flow flow中流程图大致分为两部分 定义元素 定义走向 Flow元素 语法：tag=\u003etype: content:\u003eurl type后的冒号与文本之间一定要有个空格。 tag : 元素名称 type : 元素类型(必须小写) start : 开始 end : 结束 operation : 操作 subroutine : 子程序 condition : 条件 input : 输入 output : 输出 content : 内容 url : 链接 连接Flow元素 用-\u003e来连接两个元素 形成一个流程。 Element1-\u003eElement2-\u003eElement3 condition类型有两个分支，所以要分为两个流程。 括号内的yes/no必须小写 c1(yes)-\u003eEnement1 c2(no)-\u003eElement2 若在连接元素后加上(left)/(right)/(top)/(buttom)即表示：相对该元素向左/右/上/下延伸 Flow示例 s1=\u003estart: Start e1=\u003eend: First End e2=\u003eend: Second End c1=\u003econdition: choose o1=\u003eoperation: operate s1-\u003ec1(yes)-\u003ee1 c1(no)-\u003eo1(right)-\u003ee2 ```flow s1=\u003estart: Start e1=\u003eend: First End e2=\u003eend: Second End c1=\u003econdition: choose o1=\u003eoperation: operate s1-\u003ec1(yes)-\u003ee1 c1(no)-\u003eo1(right)-\u003ee2 ``` mermaid mermaid中流程图元素是边定义边连接的。 但在此之前需先定义是横向还是纵向。 定义语法：graph type type : 类型 LR : 横向 TD : 纵向 不同于flow，最后的结尾需换行打end。 Mermaid元素 Element : Name Symbol1 Text Symbol2 类似于夹心饼干，或者说颜文字 Element : 元素 Name : 元素名称 Symbol1 : 元素形状开头标记，需与结尾标记对应 [ 矩形 ( 圆角矩形 { 菱形 \u003e 右向旗帜 (( 圆形 Text : 文本 Symbol2 : 元素形状结尾标记，需与开头标记对应 ] 矩形 ) 圆角矩形 } 菱形 ] 右向旗帜 )) 圆形 连接Mermaid元素 连接语法：Element1 Symbol1 Text Symbol2 Element2 连接两个元素 Element1 : 连接的起点元素 Symbol1 : 开始符号，需与结束符号对应 == : 粗线 -. : 细线 -- : 无箭头 Text : 文本 Symbol2 : 结束符号，需与开始符号对应 == : 粗线 -. : 细线 -- : 无箭头 Element2 : 连接的终点元素 Mermaid示例 graph TD id1(圆角矩形)--普通线--\u003eid2[矩形]; subgraph 子图 id2==粗线==\u003eid3{菱形} id3-.虚线.-\u003eid4\u003e右向旗帜] id3--无箭头---id5((圆形)) end graph TD id1(圆角矩形)--普通线--\u003eid2[矩形]; subgraph 子图 id2==粗线==\u003eid3{菱形} id3-.虚线.-\u003eid4\u003e右向旗帜] id3--无箭头---id5((圆形)) end ```mermaid graph TD id1(圆角矩形)--普通线--\u003eid2[矩形]; subgraph 子图 id2==粗线==\u003eid3{菱形} id3-.虚线.-\u003eid4\u003e右向旗帜] id3--无箭头---id5((圆形)) end ``` ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:4","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"待办事项(Todo) 语法：- [ ] 文本 或 - [X] 文本，X不限大小写 X代表已完成 案例 未完成 已完成 - [ ] 未完成 - [x] 已完成 参考网址： [1] 菜鸟教程 [2] 简书.ColdRomantic.在Markdown中输入数学公式 [3] 简书.Jlan.用markdown`来画流程图 [4] 简书.VsCode支持的markdown语法参考 [5] MarkDown规则 年纪八十到九十的老人 ↩︎ 火花 ↩︎ 不是所有Markdown编辑器都支持 ↩︎ ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:5","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"在长久以来的单人Minecraft后，即使其游玩内容丰富，但仍想找到志同道合的朋友一起游玩去创造美好回忆。而中国版Minecraft可以说是限制颇大了，因而国际版Java服务器可以说是联机的首选了。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"前期准备 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"设备准备 选其中一个即可： 一台联网电脑，性能满足游戏需求，系统优先级为Linux \u003e Windows = Mac。 云服务器 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"环境准备 Java ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"知识准备 基本电脑知识 基础Linux知识(Linux系统) 一定英语水平，便于解决疑难问题 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:3","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"服务器根目录 推荐创建在带快照的文件系统内。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"个人电脑 Linux系统 Btrfs或ZFS文件系统 分区快照 Ext4或XFS 无快照 Windows系统 NTFS文件系统 全区快照 Mac OS系统 APFS文件系统 全区快照 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"云服务器 云快照 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"环境准备 自行查找Java的安装。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"服务器安装 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"原版 版本 在其中挑选所需的服务器版本，如有模组需注意二者Minecraft版本的匹配。 { \"id\": \"1.20.1\", \"type\": \"release\", \"url\": \"https://piston-meta.mojang.com/v1/packages/30e78c499d4df02aab34a811e290c1805f925105/1.20.1.json\", \"time\": \"2024-04-03T06:24:18+00:00\", \"releaseTime\": \"2023-06-12T13:25:51+00:00\" }, 从中获取版本号对应的URL并打开此json文件，在其中找到downloads元素(第165行) \"downloads\": { \"client\": { \"sha1\": \"4e969a3079409732a39aa722ea61d03876c41367\", \"size\": 25230298, \"url\": \"https://piston-data.mojang.com/v1/objects/4e969a3079409732a39aa722ea61d03876c41367/client.jar\" }, \"client_mappings\": { \"sha1\": \"85283b9708072cada19de2a29955957939af2127\", \"size\": 9308979, \"url\": \"https://piston-data.mojang.com/v1/objects/85283b9708072cada19de2a29955957939af2127/client.txt\" }, \"server\": { \"sha1\": \"00cab0438130dc3e6ae91f53387bb96ae7986d31\", \"size\": 50546942, \"url\": \"https://piston-data.mojang.com/v1/objects/00cab0438130dc3e6ae91f53387bb96ae7986d31/server.jar\" }, \"server_mappings\": { \"sha1\": \"a5e08ee736fb987f2920b98d25961245aac087bc\", \"size\": 7172652, \"url\": \"https://piston-data.mojang.com/v1/objects/a5e08ee736fb987f2920b98d25961245aac087bc/server.txt\" } }, 下载第三个元素server中的URL文件server.jar至根目录中。 在服务器根目录中执行如下命令： 该命令为初始化服务器组件与启动服务器。 java -Xmx4G -jar server.jar nogui 参数含义： -Xmx4G 最大内存4G -jar server.jar 指定server.jar为执行目标 nogui 无图形界面执行 执行完后文件目录 ├── eula.txt ├── libraries ├── logs ├── server.jar ├── server.properties └── versions 将eula.txt文件中的eula变量由false改为true 服务器配置文件为server.properties，可参照 Minecraft中文Wiki——配置服务器设置 配置 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"Forge 下载地址1 选择自己想要的版本，点击Install后跳转至下载页面 等待5秒后点击右上角的Skip即可下载 将下载的文件移至根目录中，而后执行如下命令： java -jar forge-1.20.1-48.0.39.jar --installServer 参数含义： -jar forge-1.20.1-48.0.39.jar 指定执行文件，根据自身下载的文件更改该参数 --installServer Forge自带参数 执行完后根目录如下： ├── libraries ├── run.bat ├── run.sh └── user_jvm_args.txt 执行对应系统的启动脚本： Windows: run.bat Linux与Mac OS: run.sh 执行完后根目录如下： ├── config ├── defaultconfigs ├── eula.txt ├── libraries ├── logs ├── mods ├── run.bat ├── run.sh └── user_jvm_args.txt 将eula.txt文件中的eula变量由false改为true。 模组存放于mods文件夹中。 Java启动参数在user_jvm_args.txt中设置。 服务器配置文件为server.properties，可参照 Minecraft中文Wiki——配置服务器设置 配置。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"Fabric 下载地址 下载所需版本至根目录中。 执行如下命令： 该命令为初始化服务器组件与启动服务器。 java -Xmx4G -jar fabric-server-mc.1.19.2-loader.0.14.21-launcher.0.11.2.jar nogui 参数含义： -jar fabric-server-mc.1.19.2-loader.0.14.21-launcher.0.11.2.jar 执行目标为Fabric服务器文件 -Xmx4G 最大内存为4G nogui 无图形界面 执行完毕后根目录如下： ├── eula.txt ├── fabric-server-mc.1.19.2-loader.0.14.21-launcher.0.11.2.jar ├── libraries ├── logs ├── mods ├── server.jar ├── server.properties └── versions 将eula.txt文件中的eula变量由false改为true。 模组存放于mods文件夹中。 服务器配置文件为server.properties，可参照 Minecraft中文Wiki——配置服务器设置 配置。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:3","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"防火墙 Minecraft默认端口为25565。 可在server.properties中的server-port变量配置 服务器需要公网IP供他人访问 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"IPv4 在防火墙中开启对应端口的IPv4出入。 IPv4的公网IP难以获得，若没有只能内网穿透 目前IPv4内网穿透有两种方式 Frp P2P Frp可能需要付费(有些有限流限额的免费)，但仅需服务端进行配置，客户端无需繁琐操作 P2P完全免费，但服务端与客户端都要进行专门的配置 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"IPv6 在防火墙中开启对应端口的IPv6出入 IPv6因其庞大的数量，目前所有IPv6设备都有自己的属于IPv6的公网IP。 IPv6在国内虽说普及率达到90%以上，但由于设备的报废期问题，可能受到路由器、光猫、运营商等的拦截。 注：该官网可能需要VPN才能流畅连接 ↩︎ ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]