[{"categories":["C++"],"content":"在现实世界中的物理规律都需要物理单位，相较于直接进行数字的计算，带有物理量的计算可进行量纲校验与单位换算。其中有两类，其一是静态实现，在编译期进行校验，另一种是动态实现，在运行期进行校验。为将两种方法的优点进行统一，便自行开发单位库。 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:0:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"前置需求 线性代数（关于线性空间的变换） 一些英语，有翻译也可（编程必须，不然容易看不懂变量） C++23 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:1:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"数学理解 对于相同指数下的单位的变换，可认为是一个基于一种单位基底的线性空间到另一种单位基底的线性空间的线性变换。 若对基进行变换，由于绝大部分物理单位间的变换都是线性变换，只有一个量纲下的物理量是仿射变换(说的就是你，温度)，先考虑绝大多数，那么可直接乘以一个变换矩阵，得到由新的基组成的单位。 但该前提是所有量纲的指数都是 $1$，或者说，在一个量纲中，不同的指数有不同的尺规。 如 $\\mathrm{in}$ 到 $\\mathrm{m}$ 的尺规是 0.0254，但 $\\mathrm{in}^{2}$ 到 $\\mathrm{m}^{2}$ 的尺规是 $6.4516(2.54^{2})$。 同时单位制词头的不同也带来了不同的尺规，$\\mathrm{m}$ 到 $\\mathrm{km}$ 的尺规为 $1000$，$\\mathrm{m}^{2}$ 到 $\\mathrm{km}^{2}$ 的尺规为 $1000,000$ $$ \\begin{align} \\boldsymbol{x}' \u0026= \\operatorname{diag}(m_{1,1}^{p_{1,1}}c_{1,1}^{p_{1,1}}x_{1,1},\\cdots,m_{n,n}^{p_{n,n}}c_{n,n}^{p_{n,n}}x_{n,n})\\notag \\\\ \u0026= \\operatorname{diag}[(m_{1,1}c_{1,1})^{p_{1,1}},\\cdots,(m_{n,n}c_{n,n})^{p_{n,n}}] \\boldsymbol{x}\\notag \\end{align} $$ 其中： $\\boldsymbol{p}$ 用对角矩阵表示的各量纲的指数，其中元素为 $p_{i,j}$ $\\boldsymbol{x}$ 原量纲单位的对角矩阵，其中元素为 $x_{i,j}$ $\\boldsymbol{m}$ 单位制词头的对角矩阵，在量纲指数为 $1$ 下的尺规，其中元素为 $m_{i,j}$ $\\boldsymbol{c}$ 变换的对角矩阵，在量纲指数为 $1$ 下的尺规，其中元素为 $c_{i,j}$ $\\boldsymbol{x}'$ 现量纲的对角矩阵，其中元素为 $x_{i,j}^{\\prime}$ $n$ 代表维度数 对其求行列式可得： $$ \\begin{align} |\\boldsymbol{x}'| \u0026= |\\operatorname{diag}[(m_{1,1}c_{1,1})^{p_{1,1}},\\cdots,(m_{n,n}c_{n,n})^{p_{n,n}}]| \\cdot |\\boldsymbol{x}| \\notag \\\\ \\frac{|\\boldsymbol{x}'|}{|\\boldsymbol{x}|} \u0026= |\\operatorname{diag}[(m_{1,1}c_{1,1})^{p_{1,1}},\\cdots,(m_{n,n}c_{n,n})^{p_{n,n}}]| \\notag\\\\ \\frac{|\\boldsymbol{x}'|}{|\\boldsymbol{x}|} \u0026= \\prod_{i=1}^{n}(m_{i,i}c_{i,i})^{p_{i,i}} \\notag \\end{align} $$现在再来考虑温度，在温度量纲指数为 $1$ 时，温度单位的变换为不过原点的一次函数。因而最好的就是只有一个单位：开尔文(K)。 在温度仅表示温差这一含义时，可忽略温差，只看温标。 在仅有温度这一量纲时，需同时看温标与温差。 因而，在只有温度量纲且指数为$1$ 时，允许从开尔文 $\\Longleftrightarrow$ 其他温度单位的转换。 那么有两种实现方法： 将量纲线性空间扩展为 $n+1$ 维。 单列在一次量纲的温度变换，在温度量纲中只有开尔文，如同物质的量只有摩尔一样。 本库采用方法 2 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:2:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"实现思路 单位库应包含如下内容 量纲 数 因而难点在于量纲，单位库的一切都是围绕量纲的，数只不过是附带的内容(虽然在计算中这才是主要的)。 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:3:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"头文件使用 \u003cconcepts\u003e \u003cstdfloat\u003e 可选，若觉得float过大可使用float16_t ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:3:1","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"量纲 量纲是复杂的，尤其是将静态与动态相结合的同时要有高扩展性。 在这里本人是将单位制词头与单位拆分，这样便于扩展，不用再实现同一单位的不同单位制词头。 量纲类型 单位制词头 量纲单位 指数 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:3:2","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"实现 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"数学 约束 定义数的约束(concept)： template\u003ctypename T\u003e concept rational = requires (T x, T y) { {x + y} -\u003e std::convertible_to\u003cT\u003e; {x - y} -\u003e std::convertible_to\u003cT\u003e; {x * y} -\u003e std::convertible_to\u003cT\u003e; {x / y} -\u003e std::convertible_to\u003cT\u003e; {x += y} -\u003e std::convertible_to\u003cT\u003e; {x -= y} -\u003e std::convertible_to\u003cT\u003e; {x *= y} -\u003e std::convertible_to\u003cT\u003e; {x /= y} -\u003e std::convertible_to\u003cT\u003e; {-x} -\u003e std::same_as\u003cT\u003e; x = y; requires T(3) / T(2) == T(1.5); requires std::totally_ordered\u003cT\u003e; }; template\u003ctypename T\u003e concept integral = requires (T x, T y) { {x + y} -\u003e std::convertible_to\u003cT\u003e; {x - y} -\u003e std::convertible_to\u003cT\u003e; {x * y} -\u003e std::convertible_to\u003cT\u003e; {x / y} -\u003e std::convertible_to\u003cT\u003e; {x += y} -\u003e std::convertible_to\u003cT\u003e; {x -= y} -\u003e std::convertible_to\u003cT\u003e; {x *= y} -\u003e std::convertible_to\u003cT\u003e; {x /= y} -\u003e std::convertible_to\u003cT\u003e; {-x} -\u003e std::convertible_to\u003cT\u003e; x = y; requires T(3) / T(2) == T(1) || T(3) / T(2) == T(2); requires std::totally_ordered\u003cT\u003e; }; 至于为什么不用C++自带的std::floating_point与std::integral，因为这两个追溯到根源的实现是结构的模板特化，也就是说如果有新的自定义数据类型，可以表达数与进行数运算但不会被识别为数，是不严谨的。 幂函数 在C++23中标准库仍有大部分未实现编译期常量的数学函数，其中就有pow，且所有数学函数都未实现泛型，因而要自己实现。 如下是简易的实现，便于演示没用快速幂算法。 template\u003crational T\u003e constexpr T pow(rational auto x,integral auto p){ if (p \u003e 0){ T temp = 1; for (size_t i=0;i\u003cp;i++) temp = temp * x; return temp; } else if (p == 0){ if (x != 0) return 1; else throw std::exception(); } else { T temp = 1; for (size_t i=0;i\u003c-p;i++) temp = temp / x; return temp; } } ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:1","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"基类（量纲单位） 基类是一切扩展性的根源，要保留有最高的扩展性，因而使用模板进行定义： 基类数据 其中应至少含有 尺规(magnitude)，要求范围为有理数$\\mathbb{Q}$ 指数(power)，要求范围为整数$\\mathbb{Z}$1 简名(short_name)，要求为字符串 量纲简名(dimension_short_name)，要求为字符串 如下为基类中数据的定义： template\u003crational magnitude_t,integral power_t\u003e struct basic_dimension{ magnitude_t magnitude; power_t power; std::string_view short_name; std::string_view dimension_short_name; }; 其中std::string_view还可被优化为const char* const但除非是超大量的单位存储，否则这优化是没啥必要的（因为不如std::string_view类方便，在理解意义上的） 从基类中我们定义最通用的内存空间最小类： using dimension = basic_dimension\u003cstd::float,std::int8_t\u003e; 基类函数 在基类中应有完全比较函数即operator==()函数，比较全部四个数据； 也应有类型比较函数type_equal，比较幂指数与唯一单位名； 还应有模板转换函数，为特殊超大单位提供无损转换 template\u003crational magnitude_t,integral power_t\u003e struct basic_dimension{ constexpr operator==(...) const; constexpr type_equal(...) const; static constexpr basic_dimension\u003c...\u003e convert(...) const; }; 要达成以上条件，其中的约束为： 为基类的任意派生 二者有可隐式转换的类型 template\u003ctemplate\u003crational R,integral I\u003e typename dimension_t,rational R,integral I\u003e requires requires { requires std::derived_from\u003cdimension_t\u003cR,I\u003e,basic_dimension\u003cR,I\u003e\u003e; requires std::common_with\u003cmagnitude_t,R\u003e; requires std::common_with\u003cpower_t,I\u003e; } constexpr bool operator==(const dimension_t\u003cR,I\u003e\u0026 dimen) const { ... } ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:2","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"单位制词头结构 其中有两种数据类型，这导致该结构更像是对基类（量纲单位）的包装 单位制词头 基类（量纲单位） template\u003crational magnitude_t,integral power_t\u003e struct basic_MP_dimension { MP metric_prefix; basic_dimension\u003cmagnitude_t, power_t\u003e dimen; }; 单位制词头 两种方式 采用对数表示，运用char数据类型存储 优：空间换时间（但不至于这么省，又不是极限单片机），可能大概也许比较易懂 劣：浪费计算时间 枚举类型 + 固定数组存储 优：时间换空间 劣：每多一个词头多占用4字节（默认float = float32_t，占用 32bit= 4byte） 选用第二种方法——枚举类型 + 固定数组存储。 采用std::array，会多8字节。 enum class MP : char{ Q, R, Y, Z, E, P, T, G, M, k, h, da, null, d, c, m, μ, n, p, f, a, z, y, r, q, }; auto MP_array = std::to_array\u003cfloat\u003e({ 1e30, 1e27, 1e24, 1e21, 1e18, 1e15, 1e12, 1e9, 1e6, 1e3, 1e2, 1e1, 1, 1e-1, 1e-2, 1e-3, 1e-6, 1e-9, 1e-12, 1e-15, 1e-18, 1e-21, 1e-24, 1e-27, 1e-30 }); 结构函数 与基类（量纲单位）类似 template\u003crational magnitude_t,integral power_t\u003e struct basic_MP_dimension { constexpr bool operator==(...) const; constexpr bool type_equal(...) const; static constexpr basic_dimension\u003c...\u003e convert(...) const; }; 约束略有不同，只需确保泛型模板参数之间可以隐式转换即可： template\u003crational R,integral I\u003e requires requires { requires std::common_with\u003cmagnitude_t,R\u003e; requires std::common_with\u003cpower_t,I\u003e; } constexpr bool operator==(const basic_MP_dimension\u003cR,I\u003e\u0026 MP_dimen) const { ... } ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:3","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"单位类 前面的可以说是都是基础，接下来到了重点：单位类 template\u003crational value_t,rational magnitude_t,integral power_t\u003e class basic_unit; 类型别名 使用的类型别名 V，一种类型，可转换为value_t，其约束为std::convertible_to\u003cV,value_t\u003e M，一种类型，可转换为magnitude_t，其约束为std::convertible_to\u003cM,magnitude_t\u003e P，一种类型，可转换为power_t，其约束为std::convertible_to\u003cP,power_t\u003e 以下省略V，M，P类型的约束 using dimension_t = basic_MP_dimension\u003cmagnitude_t, power_t\u003e; using MP_Less_t = MP_dimension_less\u003cmagnitude_t, power_t\u003e; 其中 MP_dimension_less 为： template\u003crational M,integral P\u003e struct MP_dimension_less { constexpr bool operator()(const basic_MP_dimension\u003cM, P\u003e\u0026 ldimen,const basic_MP_dimension\u003cM, P\u003e\u0026 rdimen) const { return ldimen.dimen.dimension_name \u003c rdimen.dimen.dimension_name; } }; 数据类型 value，类型为value_t dimens，类型为std::set\u003cdimension_t,MP_Less_t\u003e 模板类型转换 要注意因为是任意匹配类型，要进行模板类型转换才能插入 使用 basic_MP_dimension::convert 初始化 空初始化 拷贝初始化 值初始化 值与单个单位类型初始化 值与复数单位类型初始化 constexpr basic_unit() {} constexpr basic_unit(const basic_unit\u003cV, M, P\u003e\u0026 unit); constexpr basic_unit(const value_t\u0026 value); constexpr basic_unit(const value_t\u0026 value,const basic_MP_dimension\u003cM, P\u003e\u0026 dimen); template\u003cstd::ranges::input_range Rng\u003e constexpr basic_unit(const value_t\u0026 value, Rng\u0026\u0026 range); 初始化约束 因为对容器里存储类型的判断无法直接泛型，所以只能由同名变量来判断了。 template\u003cstd::ranges::input_range Rng\u003e requires requires { requires std::same_as\u003cdecltype(std::ranges::range_value_t\u003cRng\u003e::metric_prefix), MP\u003e; requires std::convertible_to\u003cdecltype(std::ranges::range_value_t\u003cRng\u003e::dimen.magnitude),magnitude_t\u003e; requires std::convertible_to\u003cdecltype(std::ranges::range_value_t\u003cRng\u003e::dimen.power),power_t\u003e; requires std::same_as\u003cdecltype(std::ranges::range_value_t\u003cRng\u003e::dimen.short_name), std::string_view\u003e; requires std::same_as\u003cdecltype(std::ranges::range_value_t\u003cRng\u003e::dimen.dimension_name), std::string_view\u003e; } constexpr basic_unit(const value_t\u0026 value, Rng\u0026\u0026 range); ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:4","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"尺度计算 value_t MagnitudeCalculateFrom(const basic_unit\u003cV, M, P\u003e\u0026 u) const { value_t all_magnitude = 1; for(auto i : dimens) { value_t magni = 1; auto dimen = basic_MP_dimension\u003cM, P\u003e::convert(i); if (auto iter = u.getDimensions().find(dimen); iter != u.getDimensions().end()){ magni *= pow\u003cvalue_t\u003e(iter-\u003edimen.magnitude / i.dimen.magnitude, iter-\u003edimen.power); magni *= pow\u003cvalue_t\u003e(MP_array[(char)iter-\u003emetric_prefix] / MP_array[(char)i.metric_prefix],iter-\u003edimen.power); } all_magnitude *= magni; } return all_magnitude; } ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:5","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"错误定义 在这里作者并未自定义错误，全部采用std::exception错误（毕竟是演示） ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:6","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"加减 对于加减的计算，先是要比较其量纲单位是否匹配，后是尺度转换，再是相加 因而其返回值为std::expected。 同时应返回的basic_unit要取二者共有的类型，即std::common_type_t\u003cmagnitude_t,M\u003e等 加减函数 以加法函数为例，错误在返回值中传出而非直接抛出 以下为函数声明2： constexpr std::expected\u003c basic_unit\u003c std::common_type_t\u003cvalue_t,V\u003e, std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e, std::exception \u003e plus(const basic_unit\u003cV,M,P\u003e\u0026 unit) const noexcept; 而在函数中为比较量纲，那么 容器大小相同，即size相同 由于使用的容器std::set为有序容器，即可直接按顺序比较即可。因为顺序不同时二者一定不同 最终返回公共类型 以下为函数实现3： if (dimens.size() == unit.getDimensions().size()) { auto i = dimens.begin(); auto j = unit.getDimensions().begin(); for (;i != dimens.end() \u0026\u0026 j != unit.getDimensions().end();) { if (!i-\u003etype_equal(*j)) return std::unexpected(std::exception()); i++; j++; } return basic_unit\u003c std::common_type_t\u003cvalue_t,V\u003e, std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e(value + MagnitudeCalculateFrom(unit) * unit.getValue(),dimens); } else return std::unexpected(std::exception()); 同理可得到减法函数 加减运算符 套用加减函数并抛出可能的错误 以加法运算符为例 auto u = plus(unit); if (u.has_value()) return u.value(); else throw u.error(); 减法运算符同理 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:7","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"乘 对于乘法，其并没有任何的错误可被抛出 乘法函数 以下为乘法的函数声明2： constexpr basic_unit\u003c std::common_type_t\u003cvalue_t,V\u003e, std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e multiply(const basic_unit\u003cV, M, P\u003e\u0026 unit) const noexcept; 对于乘法而言无需去比较量纲，但需要去尝试去找出相对应的量纲并在指数上相加，如果找不到就插入该找不到的量纲。 以下为函数实现3： std::set\u003c basic_MP_dimension\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e, MP_dimension_less\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e \u003e tmp_dimens; for (auto i : dimens){ auto dimen = basic_MP_dimension\u003cM, P\u003e::convert(i); basic_dimension\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e tmp_dimen { i.dimen.magnitude, i.dimen.power, i.dimen.short_name, i.dimen.dimension_name, }; if (auto iter = unit.getDimensions().find(dimen); iter != unit.getDimensions().end()) tmp_dimen.power += iter-\u003edimen.power; tmp_dimens.insert( basic_MP_dimension\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e { i.metric_prefix, tmp_dimen } ); } 乘法运算符 直接使用乘法函数即可 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:8","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"除 对于除法，与乘法相比需判断值是否为0 除法函数 以下为除法的函数声明2： constexpr std::expected\u003c basic_unit\u003c std::common_type_t\u003cvalue_t,V\u003e, std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e, std::exception \u003e devide(const basic_unit\u003cV, M, P\u003e\u0026 unit) const noexcept; 以下为函数实现3： if (unit.getValue() == 0) return std::unexpected(std::exception()); std::set\u003c basic_MP_dimension\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e, MP_dimension_less\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e \u003e tmp_dimens; for (auto i : dimens){ auto dimen = basic_MP_dimension\u003cM, P\u003e::convert(i); basic_dimension\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e tmp_dimen { i.dimen.magnitude, i.dimen.power, i.dimen.short_name, i.dimen.dimension_name, }; if (auto iter = unit.getDimensions().find(dimen); iter != unit.getDimensions().end()) tmp_dimen.power -= iter-\u003edimen.power; tmp_dimens.insert( basic_MP_dimension\u003c std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e { i.metric_prefix, tmp_dimen } ); } return basic_unit\u003c std::common_type_t\u003cvalue_t,V\u003e, std::common_type_t\u003cmagnitude_t,M\u003e, std::common_type_t\u003cpower_t,P\u003e \u003e(value / (MagnitudeCalculateFrom(unit) * unit.getValue()),tmp_dimens); 除法运算符 使用并抛出（如有）除法函数中的错误 ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:4:9","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"总代码 位于github 仓库中 https://github.com/Bendancom/BlogCodes ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:5:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"TODO 添加错误分类 重载std::formatter 四则运算的运算至函数与运算符（e.g. operator+=与plusto） 从字符串中转化（估计要等到C++26了，静态反射） ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:6:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"参考资料 [1] addis.物理量和单位转换[EB/OL].小时百科.https://wuli.wiki/online/Units.html 实际在物理中是真有指数为有理数的量纲操作的，但这样不好计算，详情参照 小时百科-物理量和单位转换-例3 ↩︎ 在以下情形中，V、M、P类型都是由std::common_with进行约束 ↩︎ ↩︎ ↩︎ 不同模板之间无法访问私有变量，所以只能从公开接口获取 ↩︎ ↩︎ ↩︎ ","date":"2024-08-12","objectID":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/:7:0","tags":["C++","Physics","Unit","单位","物理"],"title":"单位库实现","uri":"/posts/%E5%8D%95%E4%BD%8D%E5%BA%93%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"C++中实现了单映射STL容器std::map，但实际业务中需要的是多映射类型的对任意数据的快速查找。虽可以使用多个std::map，但这对空间浪费过大，因而作者自行实现一个简易的多索引泛型容器库。 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"实现思路 使用关联容器或自定义关联容器存储索引 使用容器存储数据表，容器类型可根据IO特性自行调整 键：数据的引用，以减少重复数据。 值：数据在总表中的位置(指针)。 容器是不能存储引用的，使用std::reference_wrapper来包装引用并存储 使用 std::tuple 封装数据。 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"标准库使用 \u003ctype_traits\u003e \u003cranges\u003e \u003ctuple\u003e \u003cvector\u003e \u003cconcepts\u003e ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"泛型 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"索引类的键值对类型 键 std::reference_wrapper 的本质是指针，即在内存中占用sizeof(size_t)大小字节，由此可进行分类： $\\geqslant$sizeof(size_t)的使用 std::reference_wrapper $\u003c$sizeof(size_t)的使用其本身 那么类型别名模板如下： template \u003ctypename T\u003e using map_key = std::conditional_t\u003csizeof(T) \u003c sizeof(size_t), T, std::reference_wrapper\u003cT\u003e\u003e; 值 泛型容器，其索引值为该泛型容器的迭代器 随机访问容器，其索引值可优化为内存地址 为泛型选择了第一种。 template \u003ctemplate \u003ctypename T, typename... Args\u003e typename container, typename... Args\u003e using map_value = std::ranges::iterator_t\u003ccontainer\u003cstd::tuple\u003cArgs...\u003e\u003e\u003e; ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:1","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"索引容器包装/解封 map_wrapper 对单个索引容器的包装 map_wrapper封装 template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename T\u003e struct map_wrapper {}; map_wrapper_expand 运用模板特化读取封装的单个索引容器类型，后接两个类型： K: 键类型 V: 值类型 直接组成一个完好的索引类。 template \u003ctypename T, typename K, typename V\u003e struct map_wrapper_expand; template \u003c template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename args\u003e typename T, template \u003ctypename, typename, typename... Args\u003e typename Other, typename K, typename V\u003e struct map_wrapper_expand\u003cT\u003cOther\u003e, K, V\u003e { using type = Other\u003cK, V\u003e; }; maps_wrapper 对不同索引的整体封装 maps_wrapper 封装 export template \u003ctemplate \u003ctypename, typename, typename... Args\u003e typename... Others\u003e struct maps_wrapper {}; maps_wrapper_expand 通过对 maps_wrapper的展开，对其中的每个索引容器单独使用 map_wrapper 封装，后组合成 std::tuple 的二层封装结构 template\u003ctypename T\u003e struct maps_wrapper_expand; template\u003ctemplate\u003ctemplate\u003ctypename, typename, typename... Args\u003etypename... args\u003etypename T, template\u003ctypename, typename, typename... Args\u003etypename...Others\u003e struct maps_wrapper_expand\u003cT\u003cOthers...\u003e\u003e { using type = std::tuple\u003cmap_wrapper\u003cOthers\u003e...\u003e; }; 踩坑 template\u003ctypename T\u003e struct maps_wrapper_expand; template\u003ctemplate\u003ctemplate\u003ctypename, typename, typename... Args\u003etypename... args\u003etypename T, template\u003ctypename, typename, typename... Args\u003etypename...Others\u003e struct maps_wrapper_expand\u003cT\u003cOthers...\u003e\u003e { template\u003ctypename V,typename... K\u003e using type = std::tuple\u003cOthers\u003cK,V\u003e...\u003e; }; 这个方法看起来可以直接一步到位，只要如下使用即可： maps_wrapper_expand\u003c maps_wrapper\u003c std::map, std::map\u003e\u003e ::type\u003c long double, int, int \u003e maps; 以上确实能通过编译。 但在引入模板后，不能通过编译。 模板如下： template\u003ctypename Maps,typename V,typename... K\u003e using maps_tuple_t =maps_wrapper_expand\u003cMaps\u003e::type\u003cV,K...\u003e; 探查下来问题大概出在可变参数模板类内的类型别名模板定义，不能在可变参数模板类中嵌套类型别名模板。 maps_tuple_before 原理是将两种可变参数分别按顺序封装到 std::tuple 中，再利用 size_t... N 统一进行展开并拼装为完整的索引类，最后封装至std::tuple中。 使用map_wrapper_expand来进行拼装 template \u003ctypename T, typename K, typename V, typename Index\u003e struct maps_tuple_before; template \u003ctypename T, typename K, typename V, size_t... N\u003e struct maps_tuple_before\u003cT, K, V, std::index_sequence\u003cN...\u003e\u003e { using type = std::tuple\u003ctypename map_wrapper_expand\u003c std::tuple_element_t\u003cN, typename maps_wrapper_expand\u003cT\u003e::type\u003e, std::tuple_element_t\u003cN, K\u003e, V\u003e::type...\u003e; }; maps_tuple 这就是最终的对索引容器处理的类，是对maps_tuple_before进行一个模板简化。 在其上增添了自动生成 std::index_sequence\u003cN...\u003e template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e struct maps_tuple { using type = maps_tuple_before\u003c associative_containers, std::tuple\u003cmap_key\u003cargs\u003e...\u003e, map_value\u003ccontainer, args...\u003e, std::make_index_sequence\u003csizeof...(args)\u003e\u003e::type; }; ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:2","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"multi_index 使用约束与模板进行泛型匹配 应有如下类型 数据容器 索引容器包装，其中含有各数据所需索引容器类型 数据 模板 template \u003c template \u003ctypename T, typename... container_args\u003e typename container, typename associative_containers, typename... args\u003e requires requires (......) { ...... } class multi_index{ ...... }; 约束 由于泛型的需求，其requires要求应为最普适，即： 数据表容器应为 common_range\u0026sized_range类型 数据量应与索引容器量一致 索引表容器应为 common_range类型，并可被std::get函数解包，且有如下函数： find insert erase count 而索引总类是由 std::tuple进行包装的，因而须函数展开进行约束计算。 requires requires( maps_tuple_t\u003ccontainer, associative_containers, args...\u003e maps, map_key\u003cargs\u003e... keys, map_value\u003ccontainer, args...\u003e value) { std::ranges::common_range\u003ccontainer\u003cstd::tuple\u003cargs...\u003e\u003e\u003e; std::ranges::sized_range\u003ccontainer\u003cstd::tuple\u003cargs...\u003e\u003e\u003e; sizeof...(args) == std::tuple_size_v\u003cdecltype(maps)\u003e; // common_range [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::ranges::common_range\u003cstd::tuple_element_t\u003cN, decltype(maps)\u003e\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); // find [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).find(keys))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // count [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003cdecltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).count(keys))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // erase [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).erase(std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); // insert [\u0026maps, \u0026value]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(std::ranges::begin(std::get\u003cN\u003e(maps))), decltype(std::get\u003cN\u003e(maps).insert({keys, value}))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // can decompress by function std::get\u003c0\u003e [\u0026maps]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e, auto \u0026\u0026...keys) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(keys), decltype(std::get\u003c0\u003e(*std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}, keys...); // can decompress by function std::get\u003c1\u003e [\u0026maps, \u0026value]\u003csize_t... N\u003e(std::index_sequence\u003cN...\u003e) -\u003e bool { return (... \u0026\u0026 std::same_as\u003c decltype(value), decltype(std::get\u003c1\u003e(*std::ranges::begin(std::get\u003cN\u003e(maps))))\u003e); }(std::make_index_sequence\u003csizeof...(args)\u003e{}); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:3","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"函数实现 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"辅助函数 模板约束中并未对索引容器要求clear与swap函数，因而需requires检验 template \u003csize_t... N\u003e constexpr void make_indexs(iterator data, std::index_sequence\u003cN...\u003e) { (std::get\u003cN\u003e(map).insert({std::get\u003cN\u003e(*data), data}), ...); } template \u003csize_t... N\u003e constexpr void erase_indexs(const iterator \u0026iter, std::index_sequence\u003cN...\u003e) { (std::get\u003cN\u003e(map).erase(std::get\u003cN\u003e(map).find(std::get\u003cN\u003e(*iter))), ...); } template \u003csize_t... N\u003e constexpr void clear_indexs(std::index_sequence\u003cN...\u003e) requires requires(multi_index_t th) { (std::get\u003cN\u003e(th).clear(), ...); } { (std::get\u003cN\u003e(map).clear, ...); } template \u003csize_t... N\u003e constexpr void swap_indexs(multi_index_t \u0026other, std::index_sequence\u003cN...\u003e) requires requires(multi_index_t th, multi_index_t other) { (std::get\u003cN\u003e(th).swap(std::get\u003cN\u003e(other)), ...); } { (std::get\u003cN\u003e(map).swap(std::get\u003cN\u003e(other)), ...); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:1","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"初始化 default constexpr multi_index() {} Range template \u003cstd::ranges::input_range Rng\u003e requires requires { std::convertible_to\u003cstd::ranges::range_reference_t\u003cRng\u003e, data_list_t\u003e; } constexpr multi_index(Rng \u0026\u0026t) : data_sheet(std::ranges::to\u003cdata_sheet_t\u003e(t)) { for (iterator iter = data_sheet.begin(); iter != data_sheet.end(); iter++) make_indexs(iter, std::make_index_sequence\u003csizeof...(Args)\u003e{}); } copy/move constexpr multi_index(const multi_index\u003ccontainer, associative_container, Args...\u003e \u0026d) : data_sheet(d.data_sheet), map(d.map) {} ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:2","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"迭代 begin/cbegin constexpr iterator begin() { return std::ranges::begin(data_sheet); } constexpr const_iterator cbegin() const { return std::ranges::cbegin(data_sheet); } end/cend constexpr iterator end() { return std::ranges::end(data_sheet); } constexpr const_iterator cend() const { return std::ranges::cend(data_sheet); } rbegin/crbegin constexpr reverse_iterator rbegin() requires requires(data_sheet_t data) { data.rbegin(); } { return data_sheet.rbegin(); } constexpr const const_reverse_iterator crbegin() const requires requires(data_sheet_t data) { data.crbegin(); } { return data_sheet.crbegin(); } rend/crend constexpr reverse_iterator rend() requires requires(data_sheet_t data) { data.rend(); } { return data_sheet.rend(); } constexpr const const_reverse_iterator crend() const requires requires(data_sheet_t data) { data.crend(); } { return data_sheet.crend(); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:3","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"查询 size constexpr size_t size() const { return data_sheet.size(); } empty constexpr bool empty() const requires requires(data_sheet_t data) { data.empty(); } { return data_sheet.empty(); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:4","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"修改 insert/insert_range constexpr iterator insert(const iterator \u0026iter, const data_list_t \u0026data) { iterator tmp = data_sheet.insert(iter, data); make_indexs(tmp, std::make_index_sequence\u003csizeof...(Args)\u003e{}); return tmp; } template\u003cstd::input_range Rng\u003e requires requires { std::convertible_to\u003cstd::ranges::range_reference_t\u003cRng\u003e, data_list_t\u003e; } constexpr iterator insert_range(const iterator \u0026iter, Rng \u0026\u0026data) { const size_t size = data.size(); iterator tmp = data_sheet.insert_range(iter, data); iterator i = tmp; for (size_t j = 0; j \u003c size; j++) { make_indexs(i, std::make_index_sequence\u003csizeof...(Args)\u003e{}); i++; } return tmp; } push_back/append_range constexpr void push_back(const data_list_t \u0026data) { data_sheet.push_back(data); make_indexs(std::prev(std::ranges::end(data_sheet)), std::make_index_sequence\u003csizeof...(Args)\u003e{}); return; } template\u003cstd::input_range Rng\u003e requires requires { std::convertible_to\u003cstd::ranges::range_reference_t\u003cRng\u003e, data_list_t\u003e; } constexpr void append_range(Rng \u0026\u0026data) { iterator tmp = std::prev(data.end()); data_sheet.append_range(data); for (tmp++; tmp != data.end(); tmp++) make_indexs(tmp, std::make_index_sequence\u003csizeof...(Args)\u003e{}); } constexpr void clear() requires requires(data_sheet_t data, maps_tuple_t maps) { data.clear(); maps.clear(); } { data_sheet.clear(); clear_indexs(std::make_index_sequence\u003csizeof...(args)\u003e{}); } erase/pop_back/clear/pop_front constexpr iterator erase(const iterator \u0026iter) requires requires(data_sheet_t data, iterator iter) { data.erase(iter); } { erase_indexs(iter, std::make_index_sequence\u003csizeof...(args)\u003e{}); return data_sheet.erase(iter); } constexpr void pop_back() requires requires(data_sheet_t data) { data.pop_back(); } { erase_indexs(data_sheet.end()--, std::make_index_sequence\u003csizeof...(args)\u003e{}); data_sheet.pop_back(); } constexpr void clear() requires requires(data_sheet_t data, maps_tuple_t maps) { data.clear(); maps.clear(); } { data_sheet.clear(); clear_indexs(std::make_index_sequence\u003csizeof...(args)\u003e{}); } constexpr void pop_front() requires requires(data_sheet_t data) { data.pop_front(); } { erase_indexs(data_sheet.begin(), std::make_index_sequence\u003csizeof...(args)\u003e{}); data_sheet.pop_front(); } swap/resize constexpr void resize(const size_t \u0026size) requires requires(data_sheet_t data, size_t size) { data.resize(size); } { data_sheet.resize(size); } constexpr void swap(multi_index\u003ccontainer, associative_containers, args...\u003e \u0026other) requires requires(data_sheet_t data, data_sheet_t \u0026other) { data.swap(other); } { data_sheet.swap(other.data_sheet); swap_indexs(other.map, std::make_index_sequence\u003csizeof...(args)\u003e{}); } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:5","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"查找 find template \u003csize_t N\u003e constexpr std::vector\u003citerator\u003e find(const std::tuple_element_t\u003cN, data_list_t\u003e \u0026data) { std::vector\u003citerator\u003e tmp; auto iter = std::get\u003cN\u003e(map).find(data); if (iter != std::get\u003cN\u003e(map).end()) for (size_t i = 0; i \u003c std::get\u003cN\u003e(map).count(std::get\u003c0\u003e(*iter)); i++) tmp.push_back(std::get\u003c1\u003e(*++iter)); return tmp; } ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:6","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"总代码 位于github 仓库中 https://github.com/Bendancom/BlogCodes ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:5:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"TODO map_wrapper在单种容器下的自动展开 std::formatter重载 更简单的初始化，如std::make_tuple ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:6:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["C++"],"content":"参考资料 [1]:泡沫o0.【C++ 包装器类 std::reference_wrapper 】全面指南：深入理解与应用C++ std::reference_wrapper——从基础教程到实际案例分析[EB/OL].CSDN.2023/09/26.https://blog.csdn.net/qq_21438461/article/details/131297103 [2]:下学期上五年级.Modern C++ 学习笔记（20）——高级模板[EB/OL].知乎.2023/06/10.https://zhuanlan.zhihu.com/p/636178655 ","date":"2024-06-08","objectID":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:7:0","tags":["C++","Multi","Index","Range","Concepts"],"title":"多索引泛型容器类的实现","uri":"/posts/%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Markdown"],"content":"本篇技术手册由个人汇总而成。旨在撰写Markdown时便于记忆查询 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:0:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"标题 在 MarkDown 中，将#置于开头并在其后加上一个或一个以上空格用于标记标题，#越多，代表标题级数越多，最多六级。 #一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:1:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"语法 对于段落的判定，换行即可 部分MarkDown编辑器若要文字段落换行，需在换行后前一段后面加上两个或两个以上空格(如VsCode)。 用于标记的空格只能用半角空格。 如果想要写的美观，可以参考MarkDown规则文档 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:2:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"段落样式 Text : 文本 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"首行缩进 不同特殊占位符所占空白是不一样大的。 默认为不缩进。 \u0026emsp; 或\u0026#8195; 全角 \u0026ensp; 或\u0026#8194; 半角 \u0026nbsp; 或\u0026#160; 半角之半角 全角缩进 半角缩进 半角之半角缩进 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"斜体 在需斜体的文字两旁加上一个星号。 *Text* ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"粗体 在需要粗体的文字两旁加上两个星号。 **Text** ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:3","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"粗斜体 在需要粗斜体的文字两旁加上三个星号。 ***Text*** ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:4","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"分隔线 在一行中用三个或三个以上的星号(*)、减号(-)、底线(_)，可以在星号、减号、底线之间插入空格，数量不限。 *** * * * --- - - - ___ _ _ _ ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:5","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"删除线 在需要添加删除线的文字两旁加上两个波浪线。 ~~Text~~ ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:6","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"下划线 可以通过内联HTML的\u003cu\u003eText\u003c/u\u003e标签来实现。 据说有些Markdown编辑器支持++Text++这种。 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:7","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"==背景高亮== ==Text== ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:8","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"脚注 脚注是对文本的补充说明，可以通过 [^Name] 标记，标记后可以在MarkDown文档任意地方进行注释。 注释方法：[^Name]:Text Name : 标记名称 Text : 注释文本 耄耋[^1] 焱[^2] [^1]:年纪八十到九十的老人 [^2]:火花 耄耋1 焱2 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:3:9","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"列表 MarkDown支持无序列表和有序列表。 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"无序列表 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个或以上空格，然后再填写内容。 同级别星号、加号、减号的混用会导致段落之间的间距的扩大。 Markdown规范推荐全文只用一种符号去表示无序列表。 * 1 * 2 * 3 + 1 + 2 + 3 - 1 - 2 - 3 * 1 + 2 - 3 1 2 3 1 2 3 1 2 3 1 2 3 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"有序列表 有序列表使用阿拉伯数字加上点(.)和一个空格表示。 1. 1 2. 2 3. 3 1 2 3 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"子列表 对无序或有序列表增添缩进即可获得子列表 同样的Markdown规范推荐全文只用一种符号去表示无序列表。 无序子列表在整个层级出现三次及以上后，之后的无序子列表前的符号就相同了。 有序子列表在整个层级出现三次及以上后，之后的有序子列表前的符号就相同了。 * 1 * 2 * 3 * 4 * 5 1. 1 * 1-1 * 1-1-1 * 1-2 1. 1.2.1 * 1-2-1-1 2. 2 1. 2.1 2. 2.2 3. 2.3 1. 2.3.1 2. 2.3.2 3. 2.3.3 1. 2.3.3.1 * 2-3-3-2 * 2-3-3-2-1 1 2 3 4 5 1 1-1 1-1-1 1-2 1.2.1 1-2-1-1 2 2.1 2.2 2.3 2.3.1 2.3.2 2.3.3 2.3.3.1 2-3-3-2 2-3-3-2-1 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:4:3","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"区块 在段落开头加上\u003e符号后紧跟一个空格。 区块可嵌套，有几层嵌套前面就有几个\u003e符号，\u003e之间用一个或一个以上空格隔开，别忘用空格分开文字与区块标记。 区块可用于列表中，列表中也可以使用区块。使用方法只需标签的叠加。 \u003e 1 \u003e\u003e 2 \u003e\u003e\u003e 3 \u003e 1. 1 \u003e 2. 2 \u003e * 2-1 \u003e * 1 \u003e\u003e + 2 \u003e\u003e\u003e - 3 1 2 3 2-1 1 2 3 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:5:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"代码 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:6:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"片段代码 可以在代码两旁添加反引号(`)向MarkDown表示这是代码。 `printf(\"Hellow World\");` ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:6:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"代码区块 可以用四个空格或一个制表符(Tab)加在区块每一行开头向MarkDown表示这是一段代码区块。 public int Get() { return 1; } 也可以用三个反引号(`)或三个波浪号(~)包裹代码区块，并可以指定一种语言。 ```C++ int* p = 1; ``` ```C# private score = 0; ``` ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:6:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"链接 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:7:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"简单链接 使用[Name](url)或\u003curl\u003e3 Name : 链接名字 url : 地址 [百度](www.baidu.com) \u003cwww.bing.com\u003e 百度 \u003cwww.baidu.com\u003e ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:7:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"高级链接 使用[Name][var]设置一个变量，然后使用[var]:Text在文档其余任意地方给变量赋上链接值。 Name : 标记名称 var : 变量名称 Text : 注释文本 [Google][1] [1]:http://www.google.com ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:7:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"图片 使用![FailText](url \"title\" )来表示图片。 也可以使用![FailText][var]标记，然后使用[var]:url在文档任意地方给变量赋上图片链接值。 FailText : 图片加载显示失败时显示的文本 url : 图片地址 var : 变量名称 title : 图片名称 ![Picture1](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2496571732,442429806\u0026fm=26\u0026gp=0.jpg \"title 1\") ![Picture2][1] [1]:https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2595316365,4277938543\u0026fm=26\u0026gp=0.jpg \"title 2\" ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:8:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"表格 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:9:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"基础 表格的制作使用|符号分隔列，使用一个或一个以上的减号(-)分隔表头和其他行，使用换行分隔行。 注意要在每行开头和结尾加上|表示表格。 |和列之间要有一个或一个以上的空格分隔。 | Price | number | | - | - | | 1 | 2 | | 2 | 1 | ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:9:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"对齐方式 可以用下列三种格式替换减号(-)来分隔表头和其他行并表示对齐方式。 其中减号(-)同理可以一个或一个以上的数量 :- 设置内容和标题栏居左对齐。 -: 设置内容和标题栏居右对齐。 :-: 设置内容和标题栏居中对齐。 | Left | Right | center | | :-----| ----: | :----: | | block | block | block | | block | block | block | ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:9:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"高级技巧 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"HTML元素 可以使用HTML标签。 \u003ckbd\u003eCtrl\u003c/kbd\u003e+\u003ckbd\u003eAlt\u003c/kbd\u003e+\u003ckbd\u003eDel\u003c/kbd\u003e ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:1","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"转义 在特定字符前加上一个反斜杠使其单作为文字显示。 MarkDown支持以下特殊字符前加反斜杠。 \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:2","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"公式 如果要在编辑器中插入公式，可以使用一个美元符号($)包裹TeX或LaTeX格式的数学公式来实现。 单独显示的LaTeX公式用$$...$$定义。 随着LaTex的更新$与$$不再推荐使用了，行内公式使用\\(与\\)包裹，行间公式使用\\[与\\]包裹。 MathJax公式使用这里不再赘述，详情请自行搜索。 $\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$ \\(x + 1 = y\\) $$\\sum_{i=0}N\\int_{a}{b}g(t,i)\\text{d}t$$ \\[x^2 + y^2 = 1\\] $\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$ \\(x + 1 = y\\) $$\\sum_{i=0}N\\int_{a}{b}g(t,i)\\text{d}t$$\\[x^2 + y^2 = 1\\]","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:3","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"流程图 本篇会简单讲解流程图的画法，若要了解其他图表的画法，可以参考 CSDN-【Tools】MarkDown教程(四)-MarkDown中的UML图 流程图需先表示为代码块。 语言目前有三种：flow、mermaid和UML ```flow Code Block ``` ```mermaid Code Block ``` ```sequence Code Block ``` Code Block : 代码块 flow flow中流程图大致分为两部分 定义元素 定义走向 Flow元素 语法：tag=\u003etype: content:\u003eurl type后的冒号与文本之间一定要有个空格。 tag : 元素名称 type : 元素类型(必须小写) start : 开始 end : 结束 operation : 操作 subroutine : 子程序 condition : 条件 input : 输入 output : 输出 content : 内容 url : 链接 连接Flow元素 用-\u003e来连接两个元素 形成一个流程。 Element1-\u003eElement2-\u003eElement3 condition类型有两个分支，所以要分为两个流程。 括号内的yes/no必须小写 c1(yes)-\u003eEnement1 c2(no)-\u003eElement2 若在连接元素后加上(left)/(right)/(top)/(buttom)即表示：相对该元素向左/右/上/下延伸 Flow示例 s1=\u003estart: Start e1=\u003eend: First End e2=\u003eend: Second End c1=\u003econdition: choose o1=\u003eoperation: operate s1-\u003ec1(yes)-\u003ee1 c1(no)-\u003eo1(right)-\u003ee2 ```flow s1=\u003estart: Start e1=\u003eend: First End e2=\u003eend: Second End c1=\u003econdition: choose o1=\u003eoperation: operate s1-\u003ec1(yes)-\u003ee1 c1(no)-\u003eo1(right)-\u003ee2 ``` mermaid mermaid中流程图元素是边定义边连接的。 但在此之前需先定义是横向还是纵向。 定义语法：graph type type : 类型 LR : 横向 TD : 纵向 不同于flow，最后的结尾需换行打end。 Mermaid元素 Element : Name Symbol1 Text Symbol2 类似于夹心饼干，或者说颜文字 Element : 元素 Name : 元素名称 Symbol1 : 元素形状开头标记，需与结尾标记对应 [ 矩形 ( 圆角矩形 { 菱形 \u003e 右向旗帜 (( 圆形 Text : 文本 Symbol2 : 元素形状结尾标记，需与开头标记对应 ] 矩形 ) 圆角矩形 } 菱形 ] 右向旗帜 )) 圆形 连接Mermaid元素 连接语法：Element1 Symbol1 Text Symbol2 Element2 连接两个元素 Element1 : 连接的起点元素 Symbol1 : 开始符号，需与结束符号对应 == : 粗线 -. : 细线 -- : 无箭头 Text : 文本 Symbol2 : 结束符号，需与开始符号对应 == : 粗线 -. : 细线 -- : 无箭头 Element2 : 连接的终点元素 Mermaid示例 graph TD id1(圆角矩形)--普通线--\u003eid2[矩形]; subgraph 子图 id2==粗线==\u003eid3{菱形} id3-.虚线.-\u003eid4\u003e右向旗帜] id3--无箭头---id5((圆形)) end graph TD id1(圆角矩形)--普通线--\u003eid2[矩形]; subgraph 子图 id2==粗线==\u003eid3{菱形} id3-.虚线.-\u003eid4\u003e右向旗帜] id3--无箭头---id5((圆形)) end ```mermaid graph TD id1(圆角矩形)--普通线--\u003eid2[矩形]; subgraph 子图 id2==粗线==\u003eid3{菱形} id3-.虚线.-\u003eid4\u003e右向旗帜] id3--无箭头---id5((圆形)) end ``` ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:4","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"待办事项(Todo) 语法：- [ ] 文本 或 - [X] 文本，X不限大小写 X代表已完成 案例 未完成 已完成 - [ ] 未完成 - [x] 已完成 ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:10:5","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":["Markdown"],"content":"参考资料 [1] 菜鸟教程 [2] 简书.ColdRomantic.在Markdown中输入数学公式 [3] 简书.Jlan.用markdown`来画流程图 [4] 简书.VsCode支持的markdown语法参考 [5] MarkDown规则 年纪八十到九十的老人 ↩︎ 火花 ↩︎ 不是所有Markdown编辑器都支持 ↩︎ ","date":"2023-06-18","objectID":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/:11:0","tags":["Markdown","手册"],"title":"Markdown技术手册","uri":"/posts/markdown%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"在长久以来的单人Minecraft后，即使其游玩内容丰富，但仍想找到志同道合的朋友一起游玩去创造美好回忆。而中国版Minecraft可以说是限制颇大了，因而国际版Java服务器可以说是联机的首选了。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"前期准备 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"设备准备 选其中一个即可： 一台联网电脑，性能满足游戏需求，系统优先级为Linux \u003e Windows = Mac。 云服务器 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"环境准备 Java ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"知识准备 基本电脑知识 基础Linux知识(Linux系统) 一定英语水平，便于解决疑难问题 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:3","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"服务器根目录 推荐创建在带快照的文件系统内。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"个人电脑 Linux系统 Btrfs或ZFS文件系统 分区快照 Ext4或XFS 无快照 Windows系统 NTFS文件系统 全区快照 Mac OS系统 APFS文件系统 全区快照 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"云服务器 云快照 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"环境准备 自行查找Java的安装。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"服务器安装 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"原版 版本 在其中挑选所需的服务器版本，如有模组需注意二者Minecraft版本的匹配。 { \"id\": \"1.20.1\", \"type\": \"release\", \"url\": \"https://piston-meta.mojang.com/v1/packages/30e78c499d4df02aab34a811e290c1805f925105/1.20.1.json\", \"time\": \"2024-04-03T06:24:18+00:00\", \"releaseTime\": \"2023-06-12T13:25:51+00:00\" }, 从中获取版本号对应的URL并打开此json文件，在其中找到downloads元素(第165行) \"downloads\": { \"client\": { \"sha1\": \"4e969a3079409732a39aa722ea61d03876c41367\", \"size\": 25230298, \"url\": \"https://piston-data.mojang.com/v1/objects/4e969a3079409732a39aa722ea61d03876c41367/client.jar\" }, \"client_mappings\": { \"sha1\": \"85283b9708072cada19de2a29955957939af2127\", \"size\": 9308979, \"url\": \"https://piston-data.mojang.com/v1/objects/85283b9708072cada19de2a29955957939af2127/client.txt\" }, \"server\": { \"sha1\": \"00cab0438130dc3e6ae91f53387bb96ae7986d31\", \"size\": 50546942, \"url\": \"https://piston-data.mojang.com/v1/objects/00cab0438130dc3e6ae91f53387bb96ae7986d31/server.jar\" }, \"server_mappings\": { \"sha1\": \"a5e08ee736fb987f2920b98d25961245aac087bc\", \"size\": 7172652, \"url\": \"https://piston-data.mojang.com/v1/objects/a5e08ee736fb987f2920b98d25961245aac087bc/server.txt\" } }, 下载第三个元素server中的URL文件server.jar至根目录中。 在服务器根目录中执行如下命令： 该命令为初始化服务器组件与启动服务器。 java -Xmx4G -jar server.jar nogui 参数含义： -Xmx4G 最大内存4G -jar server.jar 指定server.jar为执行目标 nogui 无图形界面执行 执行完后文件目录 ├── eula.txt ├── libraries ├── logs ├── server.jar ├── server.properties └── versions 将eula.txt文件中的eula变量由false改为true 服务器配置文件为server.properties，可参照 Minecraft中文Wiki——配置服务器设置 配置 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"Forge 下载地址1 选择自己想要的版本，点击Install后跳转至下载页面 等待5秒后点击右上角的Skip即可下载 将下载的文件移至根目录中，而后执行如下命令： java -jar forge-1.20.1-48.0.39.jar --installServer 参数含义： -jar forge-1.20.1-48.0.39.jar 指定执行文件，根据自身下载的文件更改该参数 --installServer Forge自带参数 执行完后根目录如下： ├── libraries ├── run.bat ├── run.sh └── user_jvm_args.txt 执行对应系统的启动脚本： Windows: run.bat Linux与Mac OS: run.sh 执行完后根目录如下： ├── config ├── defaultconfigs ├── eula.txt ├── libraries ├── logs ├── mods ├── run.bat ├── run.sh └── user_jvm_args.txt 将eula.txt文件中的eula变量由false改为true。 模组存放于mods文件夹中。 Java启动参数在user_jvm_args.txt中设置。 服务器配置文件为server.properties，可参照 Minecraft中文Wiki——配置服务器设置 配置。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"Fabric 下载地址 下载所需版本至根目录中。 执行如下命令： 该命令为初始化服务器组件与启动服务器。 java -Xmx4G -jar fabric-server-mc.1.19.2-loader.0.14.21-launcher.0.11.2.jar nogui 参数含义： -jar fabric-server-mc.1.19.2-loader.0.14.21-launcher.0.11.2.jar 执行目标为Fabric服务器文件 -Xmx4G 最大内存为4G nogui 无图形界面 执行完毕后根目录如下： ├── eula.txt ├── fabric-server-mc.1.19.2-loader.0.14.21-launcher.0.11.2.jar ├── libraries ├── logs ├── mods ├── server.jar ├── server.properties └── versions 将eula.txt文件中的eula变量由false改为true。 模组存放于mods文件夹中。 服务器配置文件为server.properties，可参照 Minecraft中文Wiki——配置服务器设置 配置。 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:3","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"防火墙 Minecraft默认端口为25565。 可在server.properties中的server-port变量配置 服务器需要公网IP供他人访问 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:0","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"IPv4 在防火墙中开启对应端口的IPv4出入。 IPv4的公网IP难以获得，若没有只能内网穿透 目前IPv4内网穿透有两种方式 Frp P2P Frp可能需要付费(有些有限流限额的免费)，但仅需服务端进行配置，客户端无需繁琐操作 P2P完全免费，但服务端与客户端都要进行专门的配置 ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:1","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"IPv6 在防火墙中开启对应端口的IPv6出入 IPv6因其庞大的数量，目前所有IPv6设备都有自己的属于IPv6的公网IP。 IPv6在国内虽说普及率达到90%以上，但由于设备的报废期问题，可能受到路由器、光猫、运营商等的拦截。 注：该官网可能需要VPN才能流畅连接 ↩︎ ","date":"2023-06-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:2","tags":["Minecraft","服务器"],"title":"如何建立一个Java版Minecraft服务器","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAjava%E7%89%88minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]